#ifndef _LEGACY_MACROS_H_
#define _LEGACY_MACROS_H_

#include <dbgflags/loggers.h>
#include <dbgflags/debug_macros.h>

#ifdef __cplusplus

namespace tools {

#ifndef __TOOLS_WHY_T_H__
    typedef enum {
         NoLevel = -1U
        ,DebugLvl = 0x0000
        ,InfoLvl = 0x1000
        ,WarningLvl = 0x2000
        ,ErrorLvl = 0x3000
        ,UserLvl = 0x0
    } logLevels;

    enum why_t {
        why_first, ///< The first valid symbol for this enum

        eConstructorEntry, ///< Log the beginning of the constructor
        eConstructorProgress, ///< Log the constructor progress
        eConstructorExit, ///< Log the end of the constructor

        eMethodEntry, ///< Log the beginning of a method
        eMethodProgress, ///< Log the method progress
        eMethodExit, ///< Log the end of a method

        eDestructorEntry, ///< Log the beginning of the destructor
        eDestructorProgress, ///< Log the destructor progress
        eDestructorExit, ///< Log the end of the destructor

        eException, ///< Log from a catch exception handler

        why_last ///< The last valid symbol for this enum
    }; // enum why_t
#endif //__TOOLS_WHY_T_H__

    template <class characterType>
    inline std::basic_ostream<characterType, std::char_traits<characterType> > &getLogger(const unsigned int levelsSet) {
        if ((levelsSet & ErrorLvl) == ErrorLvl) {
            return logError;
        }

        if ((levelsSet & WarningLvl) == WarningLvl) {
            return logWarning;
        }

        if ((levelsSet & InfoLvl) == InfoLvl) {
            return logInfo;
        }

        if ((levelsSet & DebugLvl) == DebugLvl) {
            return logDebug;
        }

        // default log level when not set (or invalid)
        return logDebug;
    }

    inline const char *reason(const enum why_t tisReason) {
        switch (tisReason) {
            case eConstructorEntry: return "ConstructorEntry ";
            case eConstructorProgress: return "ConstructorProgress ";
            case eConstructorExit: return "ConstructorExit ";

            case eMethodEntry: return "MethodEntry ";
            case eMethodProgress: return "MethodProgress ";
            case eMethodExit: return "MethodExit ";

            case eDestructorEntry: return "DestructorEntry ";
            case eDestructorProgress: return "DestructorProgress ";
            case eDestructorExit: return "DestructorExit ";

            case eException: return "EXCEPTION ";
        } //switch(tisReason)
        return "";
    }

} //namespace tools

#ifndef DECLARE_TRACE_OBJECT

/**
 * Put this macro into a class header file like an attribute.
 * => useless when using the dbgflags library
 */
#define DECLARE_TRACE_OBJECT 

/**
 * Put this macro into a '.cpp' class file as a static variable to allow
 * functions logging.
 * => useless when using the dbgflags library
 */
#define IMPLEMENT_TRACE_FILE 

/**
 * Put this macro into a class implementation file.
 * if a class is defined in more than one cpp file, this macro shall be used once and only once (for a given class)
 * @param CLASS the class to be logged.
 * => useless when using the dbgflags library
 */
#define IMPLEMENT_TRACE_OBJECT( CLASS )

/**
 * Put this macro into a class implementation file.
 * if a class is defined in more than one cpp file, this macro can be used more than once (for a given class)
 * note : if a class is defined in mulktiple cpp files, use IMPLEMENT_TRACE_OBJECT in one off them and
 * IMPLEMENT_TRACE_OBJECT_MORE in  the others
 * @param CLASS the class to be logged.
 * => useless when using the dbgflags library
 */
#define IMPLEMENT_TRACE_OBJECT_MORE( CLASS )


#define TRACE_METHOD_BASE( METHOD_NAME, WHY, LEVEL )            FILTER tools::getLogger<char>(LEVEL) << tools::reason(WHY) << METHOD_NAME << std::endl

#define TRACE_METHOD_BASE_ARGS( METHOD_NAME, WHY, LEVEL, WHAT ) FILTER tools::getLogger<char>(LEVEL) << tools::reason(WHY) << METHOD_NAME << ":" << WHAT

#define TRACE_CTOR_BASE( WHY, LEVEL )                           FILTER tools::getLogger<char>(LEVEL) << tools::reason(WHY) << __FUNCTION__ << std::endl

#define TRACE_CTOR_BASE_ARGS( WHY, LEVEL, WHAT )                FILTER tools::getLogger<char>(LEVEL) << tools::reason(WHY) << __FUNCTION__ << ":" << WHAT

#define TRACE_FUNCTION_BASE( METHOD_NAME, WHY, LEVEL )          FILTER tools::getLogger<char>(LEVEL) << tools::reason(WHY) << METHOD_NAME << std::endl

#define TRACE_FUNCTION_BASE_ARGS( METHOD_NAME, WHY, LEVEL, WHAT ) FILTER tools::getLogger<char>(LEVEL) << tools::reason(WHY) << METHOD_NAME << ":" << WHAT


#define TRACE_FCT_CALL traceFunctionCall<debugLogger,char,traceFunctionCallStdStringPtrPolicy<char> > trcFuncCall(logDebug,__FUNCTION__,((debugFlags.mask &  MODULE_FLAG)!=0x0))

// Methods

#define TRACE_METHOD( NAME, LEVEL )                             FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodProgress) << NAME << std::endl

#define TRACE_METHOD_ARGS( NAME, LEVEL, ARGS )                  FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodProgress) << NAME << ":" << WHAT

#define TRACE_METHOD_ENTRY( NAME, LEVEL )                       FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodEntry) << NAME << std::endl

#define TRACE_METHOD_ENTRY_ARGS( NAME, LEVEL, ARGS )            FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodEntry) << NAME << ": " << ARGS

#define TRACE_METHOD_EXIT( NAME, LEVEL )                        FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodExit) << NAME << std::endl

#define TRACE_METHOD_EXIT_ARGS( NAME, LEVEL, ARGS )             FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodExit) << NAME  << ": " << ARGS

// Constructors

#define TRACE_CONSTRUCTOR( LEVEL )                              FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eConstructorProgress) << __FUNCTION__ << std::endl 

#define TRACE_CONSTRUCTOR_ARGS( LEVEL, ARGS )                   FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eConstructorProgress) << __FUNCTION__ << ": " << ARGS 

#define TRACE_CONSTRUCTOR_ENTRY( LEVEL )                        FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eConstructorEntry) << __FUNCTION__ << std::endl 

#define TRACE_CONSTRUCTOR_ENTRY_ARGS( LEVEL, ARGS )             FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eConstructorEntry) << __FUNCTION__ << ": " << ARGS 

#define TRACE_CONSTRUCTOR_EXIT( LEVEL )                         FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eConstructorExit) << __FUNCTION__ << std::endl 

#define TRACE_CONSTRUCTOR_EXIT_ARGS( LEVEL, ARGS )              FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eConstructorExit) << __FUNCTION__ << ": " << ARGS 

// Destructors

#define TRACE_DESTRUCTOR( LEVEL)                                FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eDestructorProgress) << __FUNCTION__ << std::endl 

#define TRACE_DESTRUCTOR_ARGS( LEVEL, ARGS )                    FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eDestructorProgress) << __FUNCTION__ << ": " << ARGS 

#define TRACE_DESTRUCTOR_ENTRY( LEVEL )                         FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eDestructorEntry) << __FUNCTION__ << std::endl 

#define TRACE_DESTRUCTOR_EXIT( LEVEL )                          FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eDestructorExit) << __FUNCTION__ << std::endl 

#define TRACE_DESTRUCTOR_EXIT_ARGS( LEVEL, ARGS )               FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eDestructorExit) << __FUNCTION__ << ": " << ARGS 

// Static methods

#define TRACE_STATIC_METHOD( NAME, LEVEL )                      FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodProgress) << NAME << std::endl 

#define TRACE_STATIC_METHOD_ARGS( NAME, LEVEL, ARGS )           FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodProgress) << NAME << ": " << ARGS 

#define TRACE_STATIC_METHOD_ENTRY( NAME, LEVEL )                FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::MethodEntry) << NAME << std::endl 

#define TRACE_STATIC_METHOD_ENTRY_ARGS( NAME, LEVEL, ARGS )     FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::MethodEntry) << NAME << ": " << ARGS 

#define TRACE_STATIC_METHOD_EXIT( NAME, LEVEL )                 FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodExit) << NAME << std::endl

#define TRACE_STATIC_METHOD_EXIT_ARGS( NAME, LEVEL, ARGS )      FILTER tools::getLogger<char>(LEVEL) << tools::reason(tools::eMethodExit) << NAME << ": " << ARGS 

// Exceptions logging

#define TRACE_EXCEPTION( THIS, METHOD_NAME, LEVEL, x )          FILTER tools::getLogger<char>(LEVEL) << tools::reason(eException) << METHOD_NAME << ": " << x 

// tools::Exception

#define TOOLS_CATCH_ALL( THIS, METHOD_NAME, LEVEL )\
   catch( tools::Exception & x )\
   {\
      ERROR_STREAM << "Tools Exception caught " << std::endl; \
   }

#define TOOLS_CATCH_ALL_AND_RETHROW_NOTHING( THIS, METHOD_NAME, LEVEL )\
   catch( tools::Exception & x )\
   {\
      try\
      {\
         ERROR_STREAM << "Tools Exception caught " << std::endl; \
      }\
      catch(...){ CRITICAL_STREAM << "Tools'Exception caught " << std::endl; \}\
   }

#define TOOLS_RETHROW_ALL( THIS, METHOD_NAME, LEVEL )\
   catch( tools::Exception & x )\
   {\
      ERROR_STREAM << "Tools'Exception caught " << std::endl; \
      throw;\
   }

// std::exception

#define STD_CATCH_ALL( THIS, METHOD_NAME, LEVEL )\
   catch( const std::exception & x )\
   {\
      ERROR_STREAM << "std::exception caught " << x.what() << std::endl; \
   }

#define STD_CATCH_ALL_AND_RETHROW_NOTHING( THIS, METHOD_NAME, LEVEL )\
   catch( const std::exception & x )\
   {\
      try\
      {\
         ERROR_STREAM << "std::exception caught " << x.what() << std::endl; \
      }\
      catch(...){ CRITICAL_STREAM << "Tools'Exception caught " << std::endl; \}\
   }

#define STD_RETHROW_ALL( THIS, METHOD_NAME, LEVEL )\
   catch( const std::exception & x )\
   {\
      ERROR_STREAM << "std::exception caught " << x.what() << std::endl; \
      throw;\
   }

// ... exception

#define CATCH_ALL( THIS, METHOD_NAME, LEVEL )\
   catch( ... )\
   {\
      CRITICAL_STREAM << "Catch all Exception caught " << std::endl; \
   }

#define CATCH_ALL_AND_RETHROW_NOTHING( THIS, METHOD_NAME, LEVEL )\
   catch(...)\
   {\
      try\
      {\
         CRITICAL_STREAM << "Catch all Exception caught " << std::endl; \
      }\
      catch(...)\
      {\
         CRITICAL_STREAM << "2nd Catch all Exception caught " << std::endl; \
      }\
   }

#define CATCH_ALL_AND_RETHROW_NOTHING_IN_FUNCTION( FUNCTION_NAME, LEVEL )\
   catch(...)\
   {\
      try\
      {\
         CRITICAL_STREAM << "Catch all Exception caught " << std::endl; \
      }\
      catch(...)\
      {\
         CRITICAL_STREAM << "2nd Catch all Exception caught " << std::endl; \
      }\
   }

#define RETHROW_ALL( THIS, METHOD_NAME, LEVEL )\
   catch( ... )\
   {\
      CRITICAL_STREAM << "Catch all Exception caught " << std::endl; \
      throw;\
   }

#endif /* DECLARE_TRACE_OBJECT */

#endif /* __cplusplus */

#endif //_LEGACY_MACROS_H_
